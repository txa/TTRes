\documentclass[a4paper,11pt]{article}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{alltt}
\usepackage{stmaryrd}
%\usepackage{a4wide}
\usepackage{times}
\usepackage{setspace}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm]{geometry}
%\usepackage{fancyheadings}
 
%\usepackage[PostScript=dvips]{diagrams}
%\input epsf
%\input{prooftree}
%\renewcommand{\printlandscape}{\special{landscape}}
\usepackage{pstricks,pst-node,pst-text,pst-tree,pst-3d}
\usepackage{graphicx}
\usepackage{lscape}
\usepackage{pst-grad}
\usepackage{pst-xkey}
\usepackage{multido}

\newcommand{\HLine}{\rule{\textwidth}{1pt}}
\newcommand{\Head}[1]{{\bf #1}\vspace{-2ex}\\\HLine}
\newcommand{\HeadC}[1]
  {{\begin{center}{\bf #1}\end{center}}\vspace{-2ex}\HLine}
\newcommand{\HeadB}[1]{\Head{\Blue{#1}}}
\newcommand{\Nn}{\mathbb{N}}


 \newcommand{\sem}[1]{[\![{#1} ]\!]}
 \newcommand{\imp}{\Rightarrow}
\newcommand{\subn}[1]{\langle\mathtt{new}_{\mathit{C}}/{#1}\rangle}
\newcommand{\triple}[3]{\{{#1}\}\ {#2}\ \{{#3}\}}
\newcommand{\bt}{\ensuremath{\cal B}}
\newcommand{\ct}{\ensuremath{\cal C}}
\newcommand{\defval}{\text{def}}
\newcommand{\variable}[1]{{\frenchspacing\ensuremath{\textit{#1}}}}
\newcommand{\syntax}[1]{\texttt{\def\{{\char123}\def\}{\char125}#1}}
\newcommand{\structrule}[2]{\dfrac{\strut#1}{\strut#2}}
\newcommand{\partialto}{\rightharpoonup}
\newcommand{\pll}{\mathrel{|}}
\newcommand{\trueval}{\mathit{true}}
\newcommand{\falseval}{\mathit{false}}
\newcommand{\nullval}{\mathit{null}}
\newcommand{\selectop}[3]{\{ {#1}\in {#2}\ |\ {#3}\}}
\newcommand{\setopsop}[3]{{#2} \, {#1}\, {#3}}
\newcommand{\forallop}[3]{\forall {#2}\in {#1}.\, {#3}}
\newcommand{\includesop}[2]{{#2}\in {#1}}

 
%\title{Separation Logics for High-Level Languages with\\ Code Pointers\\ {\small Case for Support}}
%\title{Local and Modular Reasoning  about  Code as First Class Type\\ \emph{---~Case
 % for Support~---}}
%\title{Reasoning about Stored Commands:\\ From Function Pointers to Self-modifying Programs
%\\ \emph{---~Case  for Support~---}}
  
  \title{Type Theory with hidden monotonic Resources\\ \emph{---~Case
  for Support~---}}


 %\title{Verifying Programs with Function Pointers and Self-modifying Features\\ \emph{---~Case
  %for Support~---}}
 

\author{Thorsten Altenkirch \qquad Bernhard Reus\\
University of Nottingham\qquad University of Sussex}

\date{}

\begin{document}
\raggedright
\sffamily

\spacing{.87}
\maketitle

\section*{Previous Research Track Record}

\subsection*{Thorsten Altenkirch}
\sloppy Thorsten Altenkirch is a Reader at the University of
Nottingham and co-chair of the Functional Programming Laboratory
currently comprising 4 members of staff and 13 PhD students. His main
research interests are Type Theory, Functional Programming,
Categorical Methods and Quantum Computing and he has published over 50
papers in this areas which are frequently cited (h-index $\geq$
24). He has been Principal Investigator on four EPSRC projects,
including \textit{Observational Equality For Dependently Typed
  Programming} (EPSRC grant EP/C512022/1, \pounds 242,198), and
\emph{Reusability and Dependent Types} (EP/G034109/1, \pounds 244,671)
and co-investigator on two more.  He has participated in a number of
EU projects, in particular in the Coordination Action TYPES and its
predecessors. He organized the annual TYPES meeting in 2007 and
specialized workshops on Dependently Typed Programming, in 2004
(Dagstuhl seminar 04381), 2008 in Nottingham and 2010 in Edinburgh.
Altenkirch is editor of Fundamentae Informatica since 2007 and was PC
member of FLOPS12, MFPS12, MSFP12, QPL11, TLCA11, FICS10, ITP10,
WGP10, TPHOLs09 and CIE08. He was twice (in 2007 and 1012) invited Professor at
Universit\'{e} Denis Diderot for one month each and in Spring 2013 he
is a visiting researcher at the Institute for Advanced Study In
Princeton for the whole term to work on Homotopy Type Theory.

Especially relevant for the current proposal is the joint work of
Altenkirch and Swierstra on \emph{functional semantics of effects}
\cite{alti:beast,alti:tfp08,swierstra:phd} which showed how effects
can be integrated in Type Theory without giving up the appealing
simplicity of the type-theoretic approach. His recent work on relative
monads \cite{alti:fossacs10} (which is inspired by earlier joint work
with Reus \cite{alti:csl99}) demonstrates how categorical concepts can
be successfully exploited to structure type-theoretic developments.


\subsection*{Bernhard Reus} 
Dr Bernhard Reus is a Senior Lecturer in Computer Science at the University of Sussex with special interest in program semantics and  logics. Reus received a distinction (``summa-cum-laude'') for his  PhD in Computer Science from the Ludwig-Maximilians-Universit\"at in Munich in 1996, got a Lectureship at Sussex University in 2000 and was promoted to Senior Lecturer in 2006. He is a member of the Foundations of Software Systems group in the Department of Informatics at Sussex. His recent research contributions have been in the area of program verification and semantics for  programming languages and logics, in particular languages with stored procedures. 
He led a small team to build a verification tool for C-like programs that supports (semi-)automatic reasoning about stored procedures (function pointers). In co-operation with colleagues in Saarbr\"ucken, Copenhagen, Oxford and Paris he developed new models for the elegant reasoning about recursive predicates indexed by recursively defined worlds. The models developed are presheaf-models with extra structure which is relevant to the proposed project.
  
Reus has been working in the area of  \emph{Applied Semantics}  for most of his research career. He co-authored a frequently cited new denotational  semantics for the call-by-name  $\lambda$-calculus with control operators and a derivation of an interpreter for this functional language  (Krivine's machine)   \cite{RS7} and was involved in the development of
  a  structural operational semantics of multi-threaded Java  \cite{R2} and  a  OCL like Hoare-logic for a sequential Java-like language \cite{R12}.
 
    He has also made contributions to foundations, in particular domain theory and type theory.
 One of the main results of the PI was the \emph{logical} development of  \emph{Synthetic Domain Theory}  which is a variation of Domain Theory, suggested by Dana Scott, in which  domains can be treated    simply as sets. % and functions are automatically continuous.
His distinguished  PhD thesis  \cite{R3}  laid out the formal development of  a flavour of Synthetic Domain Theory in a type-theoretical setting based on   few axioms only. Reus  verified  all theorems  \cite{R5}  using  the  proof-checker \emph{Lego} which implements a specific type theory (ECC). \emph{Lego} was  somehow a precursor of the  popular  type theoretical systems \emph{Coq} and \emph{Agda} that will be used in the proposed project.  
In order to ensure  the consistency of this formalization, a realizability model was defined \cite{R4}.    Later this work has been generalised to allow for more models in \cite{RS8} which in turn  has been generalised further by other researchers.

The two PIs have  collaborated once before in the area of type theory, developing 
  an elegant definition of $\lambda$-terms using a generalized form of polymorphism \cite{R15}. 
  At the time they also  co-organised and co-chaired   the TYPES workshop in  Kloster Irsee near Munich.


\textbf{Grants}
Reus was the sole PI on the recent EPSRC project     \emph{From Reasoning Principles for Function Pointers To Logics for Self-Configuring Programs}
      (EP/G003173/1, \pounds 390,871) 
      which investigated models and program logics for higher-order store, i.e.\  theories and tools that allow one to  prove correctness of programs  that use code pointers.   
      One application  of the developed semantics is the full  soundness proof of Pottier's \emph{capability types} \cite{R14}.
       Another outcome is a (semi-)automatic theorem prover, Crowfoot \cite{R3}, that allows one to write C-like programs with stored procedures (function pointers), specify them using pre- and postconditions and automatically prove that the procedures meet the specification using just some annotations.
   
 Reus was also the sole PI on the EPSRC project \emph{Programming Logics for Denotations  of  Recursive  Objects}  (GR/R65190/01), \pounds 62,360) on program logics for Abadi and Cardelli's  object-calculus. The main results of this project include 
a correctness proof  of the Abadi-Leino logic \cite{AbadiLeino} using  denotational semantics  \cite{R6,RS10} that can explain the inherent limitations of the Abadi-Leino logic and
a new  logic for a  simple  imperative while-language where procedures  are first class data that can be stored away and updated at runtime,  but  not dynamically allocated   \cite{RS11}.  
 
 Reus has also obtained numerous  smaller grants from the DAAD, Nuffield Foundation,  EPSRC, and the London Mathematical Society, respectively, that funded   research visits and the organisation of events at Sussex.
  
\textbf{Usual stuff?   numbers of publications? other stuff?} The PI has published numerous refereed papers and articles in international conferences (LICS, POPL, CSL, ESOP, ICALP, FOSSACS, VMCAI) and journals (TCS, MSCS, JFP, LMCS) of high standing.     He also co-chaired and co-organised events  in both areas, notably   the now well established \emph{Domains}   and  \emph{Types}  workshops (in 1997, 2008 and in 1998, respectively) and co-edited journal volumes (TCS vol 264(2), MSCS vol 20(2))  and  an  LNCS volume (1657) with selected papers, respectively.
He has been the PC Chair for Domains IX (Sussex, 2008), and on the PC for Domains X (2011), Classical Logic and Computation (Brno, 2010). Reus has supervised two PhD students and externally examined two PhD students.  
%
  \section*{References}

 \newpage
 
\section*{Proposed Research}
up to 6 pages

\subsection*{Summary}
\label{sec:summary}

Dependently typed programming languages like Agda exploit a powerful type system to integrate programming and reasoning allowing us to freely move between prototypical programs and certifed deliverables. Dependently typed programming (DTP) is becoming increasingly popular and is being used for real world software like web servers and communication protocols (\emph{citation}). This raises an important issue: how to integrate effectful programming and dependent types in a way that supports the engineering of certified programs effectively? In particular we want to be able to program and reason about monotone resources like memory or threads. We are going to investigate how to use a semantic construction from category theory (presheaf models) to support the ubiquitous monotone resources building on previous work by  by Swierstra and Altenkirch (\emph{citation}) on functional specification of effects.


\subsection*{Introduction and Overview}
 Functional programming is  referentially transparent as side effects are prohibited or strictly controlled by a type system.  Modern  languages like Haskell,  Python, F\# and  object-oriented variants like OCaml and Scala  have massively contributed to the popularity of functional programming (citations needed). These languages are frequently used outside academia  (citation/examples needed, need some real life data).  (Patterns of functional Map-reduce???).
 
 One main feature of these languages is their strong type system which allows the programmer to  discover certain errors at compile time. If   the type system is rich enough such that it comprises dependent types, i.e. types that depend on program expressions, it can be used to encode program  properties (propositions-as-types). This gives rise to what is called \emph{Type theory}: a functional language  with a   type system strong enough  to express  (second-order) predicate logic. As a consequence, the verification of program properties can be done by the type checker which undoubtedly is of  huge benefit to program developers. Of course the programs will now also contain proof terms that the programmer, now also a verifier, needs to provide.
  
 Alas, functional programming is not sufficient for all applications. The so-called ``\emph{Awkward squad}'' (citation) is needed in reality, ie input/output, state, references, exceptions, concurrent threads. 
These are examples of  (impure) side effects, in functional programming modelled via monads (see Moggi/Wadler). 

 Our primary objective is to have a dependent type theory that ``includes''  such side effects (in a controlled way).
 We restrict to side effects caused by monotone resources like heap without deallocation or threads with possibility to  spawn new threads but not kill any threads.
 
 The major research question underlying this proposal is:
 \textbf{How can side effects on monotone resources be modelled inside type theory?}  
  There are two approaches to fix this problem:
 \begin{itemize}
 \item use Hoare Type  theory (references needed) where  effects and operations are \emph{added} to the type theory and \emph{axioms are postulated} all of which  need external justification. A Hoare triple type then is added that expresses the behaviour of the operations with effects. In this approach one does not build side effects into the type theory, one adds them  (disadvantages?)
 \item implement  effects and provide functional specifications for programs with effects along the lines of  Wouter Swierstra's work (citation). Here the effect is simulated using concrete data types.
However, in this approach  dependency on resources needs to be modelled explicitly. Moreover, type theory is total and so some ``smart constructors" (citation) are needed to encode everything nicely. The encodings are tedious and   not re-usable. Swierstra says: \emph{"Furthermore, the automatic weakening of references requires a decidable equality on our universe. This excludes references storing dependent types, such as dependent pairs or dependent functions. It would be interesting to investigate how to remove this restriction and better support the automatic weakening of functions that are polymorphic with respect to the shape of the heap, such as the inc function above."} (citation from his diss).
 \end{itemize}
 
 In this project we are looking to improve on the second approach.  We will try to develop  an elegant \emph{``embedded' solution}, an extension of core type theory with monotonic resources the semantics of which extends conservatively the standard semantics of type theory using an abstract data type that hides the implementation (ie the resource) but provides an interface to access the resource. We propose to do this first, by  means of a representative example, for the local state monad. We  will provide an adequate specification of the local state monad within dependent type theory and a presheaf model for it to ensure soundness.
 This kind of model is particularly apt as 
 (a) presheaves are adequate abstractions of the kind  of  dependency on a ``world'' which in our case is the resource (eg.\ the local state) in a monotone way,
 and (b) there already exist standard categorical models for (dependent) type theory where the category of types can be suitable instantiated by pre sheaf categories.
Categorical semantics delivers for free  a rich toolbox of concepts and theorems for  our models.  
 
In a dependent type theory with monotone resources  reasoning about functional programs with resources (side effects) will be possible keeping all the useful and well-loved advantages of type theory (which are?). An additional benefit is that the development of such an extension via a ``presheaf application" can be regarded and maybe established as methodology for potentially other extensions of type theory. 
 
 \subsection*{Background}
 
\subsection*{Functional Programming}
\label{sec:funct-progr}

The \textbf{Functional Programming} paradigm~\cite{backus:fp} presents
computation as the evaluation of mathematical \emph{expressions} built
by   function application rather than the execution of
\emph{commands} which update and change machine states. 
Therefore, functional
languages  abstract away from operational details, allowing
programs to exhibit much more clearly their conceptual
structure. Modern functional languages like Haskell~\cite{haskell} and
OCaml~\cite{ocaml} possess very powerful mechanisms for abstraction
and re-use, facilitating brevity, clarity, reliability and
productivity. At the same time, they possess production-quality
compilers, most notably the Glasgow Haskell Compiler (GHC) and the
Objective Caml system, with substantial libraries capable of
sustaining a growing programmer base in practical application
development. As computer systems become more complex and distributed,
functional programming's 
clarity and hygiene become ever more significant virtues, one of the
reasons why the designers of mainstream languages such as Java, C\#{}
and Visual Basic are increasingly adopting ideas from the functional
world, e.g.\ polymorphism to support the safe reuse of parametric
software components.  

Over the years, the r\^ole of \emph{types} in functional programming has
become increasingly significant. In the landmark Hindley-Milner system, types
are fully inferred by machine~\cite{damas.milner:principal} and they in no
way determine the operational behaviour of programs---the assignment of a
type merely confirms that a program will not `go wrong' in an especially
disorderly manner. More recently, languages like Haskell have supported type
systems which drop full mechanical type inference, allowing
explicit types to express more subtle design statements than a machine
could determine for itself. Moreover, type-directed programming
approaches \cite{wadler.blott:less.ad.hoc,weirich:type-cast} depend
crucially on type information to determine what programs mean.

\subsection*{Dependent Types}
\label{sec:depend-typed-progr}

\textbf{Dependent types} are types which refer to (hence depend on)
data. A typical example is the type of vectors: the type
$\mathrm{Vec}\,A\,n$ represents sequences of elements of type $A$
that have  length $n$.
Vectors refine the ubiquitous types of lists $[A]$.
Conventionally, a program $\mathrm{idM}$ computing the identity
matrix, represented as a sequence of sequences of real numbers, of a
given finite dimension would have the type $\mathrm{idM} : \Bbb{N} \to
[[\Bbb{R}]]$. In a dependently typed language the same program could
be given the more informative type $\mathrm{idM} : (n:\Bbb{N}) \to
\mathrm{Vec}\,(\mathrm{Vec}\,\Bbb{R}\,n)\,n$, clearly indicating the
relationship between the value of the input and the structure of the
output; and documenting the fact that $\mathrm{idM}$ always returns
square matrices.

Dependent types have their origin in the constructive
foundations of mathematics \cite{martinloef:atheoryoftypes} developed
by the Swedish philosopher and mathematician Per Martin-L\"of, who
showed that the \emph{Curry-Howard} isomorphism between simple types
and propositional logic naturally extends to an isomorphism between
dependent types and higher-order constructive logic.  Exploiting this
equivalence between logical propositions and types, dependent types
have been used as the basis for proof assistants --- the most advanced
system developed in Europe, Coq \cite{coq}, has been used to formalize
Mathematics (e.g.\ the proof of the four colour theorem
\cite{gonthier:four-colour-paper}) and to verify programs (e.g.\
correctness of a C compiler~\cite{compcert,compcert-back,compcert-front}).

\subsection*{Dependently Typed Programming}

Currently, the development of  certified software is more an art
than a science. Types are used to enforce basic sanity conditions but
their scope is limited and not easily expandable without moving to a
different language, or a typed domain specific language. Formal
certification, if done at all, is performed independently of the
development effort, i.e.\ \emph{after the code has been written} 
such that the programmer's insight is lost for the verification process.
This is then compensated by using (semi-)automatic tools which have 
improved significantly over the last decade and can analyse
and prove certain properties of quite large programs like memory safety 
(see Slam, separation logic tools).
To be efficient, however, they need to restrict the program
properties analysed.
Implementing proof rules in DTP can build a bridge to the more conventional
vérification techniques (?? clearer).


Dependent types give 
%programmers with language to
%ommunicate the design of software to computers
%and expose its motivating structure. 
programmers   a type
system at hand that doubles as a logic.
This set programmers  free to negotiate their place in the spectrum
of properties that programs are supposed to satisfy: from  memory safety
to  full functional correctness. This \emph{pay as you go} approach allows
one to 
%raise hygiene standards in programming and 
improve guarantees in a flexible way.
%(e.g., removing tags and tests on validated data)
%but to stop when requirements become too severe.
Such expressive types can also contribute to software engineering
methods and processes through interactive, type-directed development
environments.

During the past decade we have progressed considerably towards the
goal of exploiting dependent types in functional programming.  Augustsson's
Cayenne~\cite{augustsson:cayenne} showed how functional programmers
could use dependent types to their advantage by giving static types to
conventionally untypable programs line \texttt{printf} or
\texttt{scanf}, or by implementing a tagless interpreter exploiting
type information to avoid dynamic type checking at runtime. The torch
was carried further by McBride's implementation of
Epigram~\cite{conor.james:viewfromleft}, with funding from EPSRC
(\textit{Epigram: Innovative Programming with Inductive Families} -
GR/N72259), introducing both an implementation of Wadler's views
\cite{wadler:views}
within a dependently typed framework, and an interactive IDE using
types to guide the implementation process. On the subsequent EPSRC
project (\textit{Observational Equality For Dependently Typed
  Programming} - EP/C512022/1), Thorsten Altenkirch and Conor McBride
made significant progress on one of the thorniest technical problems
for dependently typed programming---how to represent equality \cite{alti:ott-conf}.  More
recently, Norell implemented Agda~\cite{agdawiki,ulf:thesis}, a more
scalable implementation of dependently typed programming, strongly
influenced by Cayenne and Epigram.

Recent developments in functional programming
languages provide a more conservative approach to dependently typed
programming, by insisting on a distinction between the language used
at compile time and at run time. Examples for this development are
Haskell's recently acquired Generalized Algebraic Datatypes, further
rationalized in Sheard's
\(\Omega\)mega~\cite{omega,sheard:curry-howard} and Xi's
ATS~\cite{ATS-frocos05}. Other similar developments are also taking
place in the US: Concoqtion~\cite{concoqtion1,concoqtion2}
uses Coq's
Type Theory as a compile time language, Stump's system
Guru~\cite{guru} based on his proposal for Operational Type
Theory which separates the notions of evaluation for
proofs and for programs, and Morrisett's proposal for
Ynot~\cite{ynot,morrisett:ynot}, based on Hoare Type
Theory~\cite{nanevski:htt} which uses ideas from separation logic to
encapsulate effects.

\subsection*{Dependent types and effects}
\label{sec:depend-types-effects}

Functional programming languages like Haskell can now deal very well with the so-called ``\emph{Awkward squad}'' (citation) that is needed for real-world programs. These non-pure effects include input/output, state, references, exceptions, and concurrent threads. In a way,  pure functional programming languages seem
to be better suited to integrate such and other new notions of effects (like transactional memory) than conventional imperative languages  because they do not have a built-in notion of effect.

However, when moving to dependent types, where programs may appear in types,
 it is not obvious how to extend Haskell's monadic approach to IO. Haskell's IO monad is opaque - it has no compile time behaviour (specification).  Indeed, we don't want effects to be executed at compile time. 

Hoare Type Theory (HTT) (references needed)  bypasses this issue by adding types and operations and by postulating axioms. The notion of a monad is extended to include 
Hoare triples (which form a contract with a pre- and postcondition for the state transformation prescribed by a program) to specify the behaviour of a program. The HTT approach fits very naturally 
within the Coq approach to type-theoretic program development where program and proofs are separated. An impressive suit of examples of effectful programs has been already verified using the HTT approach (citations needed). 

Yet, the HTT approach fits much less well with DTP, where programs and proofs  are tightly integrated. Postulates are generally rejected in this context because they lead to programs which do not compute. Altenkirch and Wouter (citation) have developed an alternative: \emph{functional specification of effects}
where the compile time semantics of effects is given by a functional program. For instance,  state is modelled using   purely functional  state transformers (using the state monad) at compile time but is executed using ``real'' imperative memory  at run-time. This way one can eat the pie and keep it, ie.\ one can \emph{reason}about stateful programs \emph{and run} them. The beauty of this approach is that it doesn't require any extensions to Type Theory and it also comes with its own soundness proof. Obviously, it remains to be checked that the compile-time specification agrees with the actual run-time behaviour but this issue arises in \emph{any} approach. 

The \emph{functional implementation} approach hits a serious obstacle when dealing with  monotone resources which can be explicitly allocated but never need to be deallocated. This is usually achieved by a garbage collector. In Haskell monotone resources can be dealt with easily because
 resources can only be generated by an appropriate allocation operation. However, we cannot model this fact in Type Theory because it relies on a closed world assumption. Swierstra addressed this problem by introducing an explicit dependency on resources.  To deal  with this dependency, so-called
 ``smart constructors" (citation) are in use. However, these encodings are tedious and not re-usable. Swierstra says: \emph{"Furthermore, the automatic weakening of references requires a decidable equality on our universe. This excludes references storing dependent types, such as dependent pairs or dependent functions. It would be interesting to investigate how to remove this restriction and better support the automatic weakening of functions that are polymorphic with respect to the shape of the heap, such as the inc function above."} (citation from his diss).

\subsection*{Presheaf models of Type Theory}
\label{sec:presheaf-models-type}

In the past functional programming has benefitted from Category Theory by importing some of its concepts. The ubiquitous use of monads is just one (the most famous) example for this phenomenon. 
The main objective of this proposal is yet another example of this. It is well known how to deal with monotone resources in denotational semantics, e.g.\ in case of local state, from the work of Levy and Plotkin/Power (citation):  local state can be modelled using a possible world semantics (or more technical a presheaf semantics) where the worlds correspond to the current allocation of resources (ie.\ locations in the case of state). The monotonicity of resources corresponds to \emph{functoriality} of the monad in question: a value in a given world is still valid in any extended world that corresponds to the allocation for further resources.

Such presheaf semantics will be used to define the semantics of a dependently typed program and then to give monotone resources a functional specification in this project.

 \subsection*{National Importance}
  
 This research concerns the improvement of language support for the production of certified programs and thus fits perfectly in the EPSRC's "Verification and Correctness" theme. The development of languages and tools to support the production of correct software has numerous applications in safety critical systems, medical devices and even operating systems (\emph{refer to Gerwin's verified OS? Msoft's verified device drivers?}).
The EPSRC has earmarked this area for future growth and currently funds verification related projects to the extent of GBP 14 million. 
UK academics are world leaders in this field. Larger centres of excellence for DTP in the UK are Nottingham (Altenkirch, grant "Reusability and Dependent Types''), Oxford, and Strathclyde. Both investigators are involved in national and international collaborations with other leaders in DTP and Program Verification (\emph{explain})   
Further international leaders in the field  are G.~Morrisett (Harvard) and S.~Weirich (UPenn) in the US (see Trellys project), W.~Swierstra (Utrecht, Netherlands), T.~Streicher (Darmstadt) and M.~Hofmann (LMU Munich) in Germany and the programming logic research group in Chalmers (Gothenburg, Sweden).

 The success of the proposed research programme will have potential impact not only on the DTP community but also on  the design of functional programming languages with rich type systems  in general. 
 The research outcomes are expected to enable programmers to enjoy the advantages of functional programming and effectful programming at the same time without losing the ability to prove programs correct.
 Long term it is expected that such languages will become more popular and  more widely used in software engineering (world wide), potentially  reducing the economic loss caused by malfunctioning software (estimated around 150\$ in the US alone by by David Rice 2009, source: html).
 %http://news.cnet.com/8301-13846_3-9978812-62.html).
 
 \subsection*{Academic Impact}
 
\emph{ Describe how the research will benefit other researchers in the field and in related disciplines, both within the UK and elsewhere.}

clear for the academic community but further afield?

\emph{What will be done to ensure that they can benefit?
Explain any collaboration with other researchers and their role in the project.}

\emph{ For each Visiting Researcher, set out why they are the most appropriate person, and what they will contribute to the project.}

visiting researchers?  Who shall we nominate?

Wouter Swierstra, Greg Morrissett?   Thomas Streicher, Jeremy Gibbons?

We should then say which work packages they will contribute for. Project partners should send letter of support as far as I understand.

We don't have any industrial partners/visitors. is that a problem?

 \subsection*{Research Hypothesis and Objectives}
 While it is clear in principle that any dependently typed program can be given a presheaf semantics and that with this interpretation monotone resources can be given a functional specification, it is not yet clear how to use this idea in practice. What does it mean to interpret a given program or proof  in a presehaf semantics? How can objects in this presheaf workd interact with ordinary objects? And how can we combine different notion of monotone effects which lead to different presehaf interpretations in one program?

 \emph{Set out the research idea or hypothesis.
Explain why the proposed project is of sufficient timeliness and novelty to warrant consideration for funding.
Identify the overall aims of the project and the individual measurable objectives against which you would wish the outcome of the work to be assessed.}

Our hypothesis is that we can develop a purely functional
specification of monotone resources in functional programming
exploiting the presheaf semantics of Type Theory. This extends the
scope of dependently typed programming and makes it feasible to
develop real world applications relying on monotone resources.

% Our hypothesis: we can safely embed monotone resources in type theory and this leads to   elegant programs that make side effects amenable to the functional programmer.

Objectives
\begin{itemize}
\item Show that the presehaf semantics of Type Theory can be used to
  model monotone resources,
\item Define a syntactic extension of Type Theory which makes it
  possble to interpret type theoretic programs wrt to different presheaves,
\item Implement this extension as an extension to the Agda system,
\item Study different applications of presheaf type theory to
  monotone resources and show their usability.
\item Investigate other applications of presheaf type theory.
\end{itemize}


\subsection*{Programme and Methodology}

 \emph{Detail the methodology to be used in pursuit of the research and justify this choice.
Describe the programme of work, indicating the research to be undertaken and the milestones that can be used to measure its progress. The detail should be sufficient to indicate the programme of work for each member of the research team. Explain how the project will be managed.}

We will be using dependently typed programming not just as the
objectve but also as the vehicle carrying out the research. That is we
will develop our programs and theorems using the Agda system.
We will be using local state as our guiding example and first study 
how to use presheaf semantics to program and reason about this
particular resource. We will be using the experiences gained here to
develop a generic interface for presheaf interpretations of Type
Theory and will implement an extension to Agda facilitating this
approach. We will the study other examples of monotone resources
such as threads and transaction based memory. In particular we plan to
develop some interesting certified programs using monotone resources
in this approach (examples ?). We will also study other potential
application of presheaf Type Theory such as higher order abstract
syntax. 





 

We detail the work packages. Before we need to point out that we use the local state monad as guiding example, that we use presheaf semantics as we know it can deal with such monotone resource already. 
\spacing{0.85}
 \bibliographystyle{alpha}
 
 
\newpage
\section*{Work Plan}
one page, they like GANTT or PERT charts.

 \begin{enumerate}
 \item Define Presheaf semantics for core Type Theory
 \item Model the monotone resources in the above
 \item Agda implementation
 \item Examples using local state
 \item Develop generic interface for Type Theory with monotone resources by reflection of semantics 
 \item Investigate combination of various resources and resource models
 \item More examples using other monotone resources.
 \item Investigate other application of presheaf type theory
 \end{enumerate}
 
\subsection*{Task list}

\begin{enumerate}
 \item 
 \item 
 \item 
 \end{enumerate}
 

\newpage
\section{Justification of Resources}

up to 2 pages
\subsection{Directly Incurred Costs}
\paragraph*{Staff} 

 We request two Research Assistants (scale 6 or 7(?)) to help with ? \textbf{need to make twos fit with the workplan.}
 Ideally, the first RA would have some experience in one or several of the following: (dependent) type theory, effect systems, category theory, sheaf semantics.  The second RA would ideally have a good grasp of functional  programming, ideally with Agda and or Coq and good knowledge about side effects and/or category theory. 
 
 
\paragraph*{Travel and Subsistence} To present (partial) results and keep contact to other researchers in the same or related area support for attendance of  5  international workshops or conferences for both PIs and RFs    e.g.\  ETAPS, POPL, LICS, CSL, ICALP,  Types Workshops as well as national meetings such as BTCS and ``Fun in the Afternoon''.  The list of conferences is provisional, precise plans cannot be made until the details of the conferences' locations, dates and programmes are known. Note that we calculate an average cost of 900\pounds but some trips inside Europe will be cheaper but this is compensated by trips to Asia or the US which will be more expensive.  (4 times 5 times \pounds1,000    = \pounds 20,000 ).

To establish communication between the two sites involved  trips between Sussex and Nottingham are requested as follows:  4 times 4 one day day visits  by each member (\pounds 70 times 16 = \pounds 1,120)  and  3 times 4 two day visits  (6 times   \pounds  150 =  900\pounds).
  
Also included are short trips within  the UK for an exchange with researchers working in the same area, e.g.\ Birmingham (Levy), London (?) (10 times 80\pounds plus 10 times 18\pounds = 980\pounds).

For each Visiting Researcher we plan two one week (or one two week) stays at one of the  project sites. Only travel and subsistence need to be  budgeted for each of their  stays (n times 600\pounds = ?).

 
In order to maximise impact and for networking purposes we plan to organise a small specialist workshop in the topic. For this we request \pounds2000 to to pay for travel and subsistence of speakers and \pounds 500 for coffee and meals.

\paragraph*{Consumables} 
The two RAs will require a PC. The University of Nottingham and Sussex, resp., do not provide machines for RAs so two such PCs (\pounds 1000 each) are requested.
 
 \subsection{Directly Allocated Costs}
 Investigators will work about 7 to 8 hours a week?

?




\subsection{Exceptions}
  
 
 \newpage
 
 \section{Pathways to Impact}
 up to 2 pages
 
 \emph{Use this annex to the proposal to describe activities that can be undertaken during the project to accelerate the route to the identified benefits being realised; shortening the time between discovery and use of knowledge. Also identify the additional resources needed to undertake these activities. }
 
 \emph{In summary, the document should describe the kinds of impact envisaged, how the proposed research project will be managed to engage users and beneficiaries and increase the likelihood of impacts, including (wherever appropriate):
    Methods for communications and engagement\\
    Collaboration and exploitation in the most effective and appropriate manner\\
    The project team’s track record in this area\\
    The resources required for these activities.\\
     Please ensure these are also captured in the financial summary and the Justification of Resources.
}

\end{document}










 